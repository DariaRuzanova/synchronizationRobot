# synchronizationRobot
## Задача 1. Робот-доставщик
Описание

Представьте, что перед вашей командой поставили задачу на разработку программного обеспечения для робота-доставщика. Инструкции для робота содержат команды:

    R - поверни направо;
    L - поверни налево;
    F - двигайся вперед.

В процессе построения карты маршрутов, вам поручили проанализировать разнообразие существующих путей. Для генерации маршрутов вы используете функцию:

    public static String generateRoute(String letters, int length) {
        Random random = new Random();
        StringBuilder route = new StringBuilder();
        for (int i = 0; i < length; i++) {
            route.append(letters.charAt(random.nextInt(letters.length())));
        }
        return route.toString();
    }

Напишите многопоточную программу, которая в каждом потоке генерирует текст: generateRoute("RLRFR", 100), считает количество команд поворота направо (буквы 'R') и выводит на экран результат. Количество потоков равно количеству генерируемых маршрутов и равно 1000.

Так как буква 'R' в параметре генератора упомянута три раза из пяти, то в среднем, количество букв 'R' должно составлять 60% от всех команд инструкции, т.е. где-то около 60 от общего числа маршрутов. Однако, т.к. процесс вероятностный, точное количество раз которое встретится эта буква в каждом маршруте может немного отклоняться от среднего значения.

Запустив программу, вы обратили внимание, что размеры промежутков с буквой 'R' часто повторяются и вам стало интересно, какие размеры попадаются чаще всего.

Для этого вы завели мапу в статическом поле public static final Map<Integer, Integer> sizeToFreq, которая после завершения потоков должна хранить в ключах попавшиеся частоты буквы 'R', а в значениях - количество раз сколько они попались. В итоге, обработав каждую строку, вам нужно будет обновить эту мапу, увеличив значение для полученной частоты в ней на 1 (а если частоты в мапе не было - просто вставить значение 1).

Однако возникает проблема - Map не потокобезопасна, к ней нельзя обращаться из разных потоков "одновременно". Решением этой проблемы будет использование блока синхронизации (synchronized).

Реализуйте этот функционал и в конце основного потока выведите сообщение вида:

Самое частое количество повторений 61 (встретилось 9 раз)
Другие размеры:
- 60 (5 раз)
- 64 (3 раз)
- 62 (6 раз)
...

## Задача 2. Частота операций
Описание

В процессе создания программы для робота-доставщика вы решили сделать так, чтобы каждый раз когда обновляется мапа sizeToFreq на экран выводился бы текущий лидер среди частот. Для этого придётся просматривать весь Map в поисках лидера, что достаточно затратно.

Вместо того чтобы делать это в том же потоке, что и считал размер, заведите один отдельный поток, который будет заниматься только подсчётом максимума в мапе и выводом этой информации на экран. Делать он это будет в цикле, а чтобы подсчёт и вывод происходили только когда нужно, он будет ждать "сигнала" через wait-notify от считающих потоков.

Условием цикла поставьте проверку на то, что поток не прервали. В основном потоке после for с join прервите этот выводящий максимумы поток.
На проверку отправьте ссылку на ветку freqlog в вашем репозиториии с решением.
